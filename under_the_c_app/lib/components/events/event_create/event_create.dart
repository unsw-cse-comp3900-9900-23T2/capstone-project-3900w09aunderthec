import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import 'package:under_the_c_app/components/events/event_create/dropdown_list.dart';
import 'package:under_the_c_app/components/events/event_create/tags.dart';
import 'package:under_the_c_app/config/routes/routes.dart';
import 'package:under_the_c_app/config/session_variables.dart';
import 'package:under_the_c_app/providers/event_providers.dart';
import 'package:under_the_c_app/types/address_type.dart';
import 'package:under_the_c_app/types/events/event_type.dart';

import '../../../providers/analytics_providers.dart';

class EventCreate extends StatelessWidget {
  const EventCreate({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        title: null,
        backgroundColor: Colors.transparent,
        elevation: 0.0,
        leading: IconButton(
            onPressed: () => context.go(AppRoutes.events),
            icon: const Icon(
              Icons.arrow_back,
              color: Colors.black,
            )),
      ),
      body: const SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            MyCustomForm(),
          ],
        ),
      ),
    );
  }
}

class MyCustomForm extends ConsumerStatefulWidget {
  const MyCustomForm({Key? key}) : super(key: key);

  @override
  MyCustomFormState createState() {
    return MyCustomFormState();
  }
}

// Create event form
class MyCustomFormState extends ConsumerState<MyCustomForm> {
  final _formKey = GlobalKey<FormState>();
  String title = '';
  String time = '';
  DateTime? chosenDate;
  TimeOfDay? dayTime;
  String venue = '';
  String description = '';
  String tags = '';
  bool isDirectRefunds = true;
  bool isPrivateEvent = true;
  bool generateButtonPressed = false;
  List<bool> selectedEventTypes = <bool>[true, false];
  List<String>? droppedItems;
  String? timePickerError;
  String? datePickerError;
  String? tagsError;

  // Save the inputs given
  void handleSelectionChanged(List<bool> newSelection) {
    setState(() {
      selectedEventTypes = newSelection;
    });
  }

  void saveSelectedTime(TimeOfDay? time) {
    setState(() {
      dayTime = time;
    });
  }

  void saveSelectedDate(DateTime? date) {
    setState(() {
      chosenDate = date;
    });
  }

  // Send variables for http request to backend and receive a list of tags generated by AI
  Future<List<String>> _fetchDroppedItems(
      String tagTitle, String tagDescription, String tagVenue) async {
    List<String> droppedItems =
        await getTags(tagTitle, tagDescription, tagVenue);
    return droppedItems;
  }

  // Format the time into 2 digits (e.g 2 -> 02)
  String formatTime(int time) {
    return time.toString().padLeft(2, '0');
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 16),
            child: Center(
              child: Text("Create Event Form",
                  style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
            ),
          ),

          // Title
          Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
              child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      "Event Title",
                      style:
                          TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                    TextFormField(
                      decoration: const InputDecoration(
                          border: OutlineInputBorder(
                              borderSide: BorderSide(
                            width: 5,
                          )),
                          hintText: "Enter the name of the event"),
                      validator: (value) {
                        // Check if field is valid
                        if (value == null || value.isEmpty) {
                          return 'Please fill out the required field';
                        }
                        return null;
                      },
                      onSaved: (value) {
                        // Save the input
                        title = value ?? '';
                      },
                    ),
                  ])),

          // Location
          Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
              child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      "Event Location",
                      style:
                          TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                    TextFormField(
                      decoration: const InputDecoration(
                          border: OutlineInputBorder(
                              borderSide: BorderSide(
                            width: 5,
                          )),
                          hintText: "Enter the place where the event is held"),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please fill out the required field';
                        }
                        return null;
                      },
                      onSaved: (value) {
                        venue = value ?? '';
                      },
                    ),
                  ])),

          // Description
          Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
              child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      "Event Description",
                      style:
                          TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                    TextFormField(
                      decoration: const InputDecoration(
                          border: OutlineInputBorder(
                              borderSide: BorderSide(
                            width: 5,
                          )),
                          hintText: "Write a short summary of the event"),
                      maxLines: 4,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please fill out the required field';
                        }
                        return null;
                      },
                      onSaved: (value) {
                        description = value ?? '';
                      },
                    ),
                  ])),

          // Date
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 5),
            child: Text(
              "Date",
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
            child: DatePicker(
              restorationId: 'main',
              saveDate: saveSelectedDate, // Save input
            ),
          ),
          // Error checking and message
          if (datePickerError != null)
            Center(
              child: Text(
                datePickerError!,
                style: const TextStyle(color: Colors.red),
              ),
            ),

          // Time
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 5),
            child: Text(
              "Time",
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
            child: TimePicker(
              themeMode: ThemeMode.dark,
              useMaterial3: true,
              getTime: saveSelectedTime, // Save input
            ),
          ),
          // Error checking and message
          if (timePickerError != null)
            Center(
              child: Text(
                timePickerError!,
                style: const TextStyle(color: Colors.red),
              ),
            ),

          // Privacy Button
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 5),
            child: Text(
              "Privacy",
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
              child: ToggleButton(
                onSelectionChanged: (handleSelectionChanged) {
                  isPrivateEvent = handleSelectionChanged[0];
                },
                boolList: eventTypes,
              )),

          // Refund Button
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 5),
            child: Text(
              "Refund Policy",
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
              child: ToggleButton(
                onSelectionChanged: (handleSelectionChanged) {
                  isDirectRefunds = handleSelectionChanged[0];
                },
                boolList: refundType,
              )),

          // Event Tags
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 5),
            child: Text(
              "Event Tags",
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 0),
            // Pressing generate button would send inputs to backend and receive input from AI
            child: generateButtonPressed
                ? FutureBuilder<List<String>>(
                    future: _fetchDroppedItems(title, venue, description),
                    builder: (context, snapshot) {
                      if (snapshot.hasData) {
                        return DropdownList(
                          droppedItem: snapshot.data!,
                          onValueChanged: (String value) {
                            tags = value;
                          },
                        );
                      } else if (snapshot.hasError) {
                        return Text('Error: ${snapshot.error}');
                      } else {
                        return const CircularProgressIndicator();
                      }
                    },
                  )
                : Container(),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 16),
            child: ElevatedButton(
              onPressed: () async {
                if (_formKey.currentState!.validate()) {
                  _formKey.currentState!.save();
                  setState(() {
                    generateButtonPressed = true;
                  });
                }
              },
              child: const Text('Generate'),
            ),
          ),
          // Error handling and message
          if (tagsError != null)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8),
              child: Text(
                tagsError!,
                style: const TextStyle(color: Colors.red),
              ),
            ),

          // Submit Button
          Center(
            child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 16),
              child: ElevatedButton(
                onPressed: () async {
                  // Check if all fields are valid
                  if (_formKey.currentState!.validate() &&
                      chosenDate != null &&
                      dayTime != null) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Processing Data')),
                    );

                    // Save all inputs
                    _formKey.currentState!.save();

                    List<String> tagsList = [];
                    tagsList.add(tags);

                    // Format time as a string
                    time =
                        "${chosenDate!.year}-${formatTime(chosenDate!.month)}-${formatTime(chosenDate!.day)}T${formatTime(dayTime!.hour)}:${formatTime(dayTime!.minute)}:00.226Z";

                    // Add event using Riverpod
                    await ref.read(eventsProvider.notifier).addEvent(
                          Event(
                            hostuid: sessionVariables.uid.toString(),
                            title: title,
                            time: time,
                            venue: venue,
                            description: description,
                            isDirectRefunds: isDirectRefunds,
                            isPrivate: isPrivateEvent,
                            tags: tagsList,
                            // tags: [tags],
                            price: 0,
                          ),
                        );
                    final uid = sessionVariables.uid.toString();
                    await ref
                        .read(eventsByUserProvider(uid).notifier)
                        .fetchEvents(uid);

                    // update the analytics page
                    await ref
                        .read(eventsYearlyDistributionProvider(uid).notifier)
                        .fetchDistribution();
                    await ref.read(eventsHostedNotifier(uid).notifier).fetch();
                    await ref
                        .read(percentageBeatenByEventsProvider(uid).notifier)
                        .fetch();

                    // prevent accessing context after it get disposed due to the async nature
                    if (context.mounted) {
                      context.go(AppRoutes.events);
                    }
                  }

                  // ===============Error Messages===============
                  // Error message for time picker
                  if (dayTime == null) {
                    setState(() {
                      timePickerError = 'Please select a time';
                    });
                  } else {
                    setState(() {
                      timePickerError = null;
                    });
                  }
                  // Error message for date picker
                  if (chosenDate == null) {
                    setState(() {
                      datePickerError = 'Please select a date';
                    });
                  } else {
                    setState(() {
                      datePickerError = null;
                    });
                  }
                  // Error message for date picker
                  if (!generateButtonPressed) {
                    setState(() {
                      tagsError =
                          'Please fill in event title, location and description';
                    });
                  } else if (tags == '') {
                    tagsError = 'Please select a tag';
                  } else {
                    setState(() {
                      tagsError = null;
                    });
                  }
                },
                child: const Text('Submit'),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// ===============Components===============
// Inputs for toggle
const List<Widget> eventTypes = <Widget>[
  Text('Private'),
  Text('Public'),
];

const List<Widget> refundType = <Widget>[
  Text('Credit Refund'),
  Text('No Refund'),
];

// True/False toggle button
// Toggle between two children OnPress
class ToggleButton extends StatefulWidget {
  final Function(List<bool>) onSelectionChanged;
  final List<Widget> boolList;
  const ToggleButton(
      {Key? key, required this.onSelectionChanged, required this.boolList})
      : super(key: key);

  @override
  State<ToggleButton> createState() => _ToggleButtonState();
}

class _ToggleButtonState extends State<ToggleButton> {
  final List<bool> _selectedEventTypes = <bool>[true, false];

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.centerLeft,
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const SizedBox(height: 5),
            ToggleButtons(
              onPressed: (int index) {
                setState(() {
                  for (int i = 0; i < _selectedEventTypes.length; i++) {
                    _selectedEventTypes[i] = i == index;
                  }
                });
                widget.onSelectionChanged(_selectedEventTypes);
              },
              borderRadius: const BorderRadius.all(Radius.circular(8)),
              selectedBorderColor: Colors.red[700],
              selectedColor: Colors.white,
              fillColor: Colors.red[200],
              color: Colors.red[400],
              constraints: const BoxConstraints(
                minHeight: 40.0,
                minWidth: 80.0,
              ),
              isSelected: _selectedEventTypes,
              children: widget.boolList,
            ),
          ],
        ),
      ),
    );
  }
}

// Pick time in 12hr format
class TimePicker extends StatefulWidget {
  const TimePicker({
    super.key,
    required this.themeMode,
    required this.useMaterial3,
    required this.getTime,
  });

  final ThemeMode themeMode;
  final bool useMaterial3;
  final ValueChanged<TimeOfDay?> getTime;

  @override
  State<TimePicker> createState() => _TimePickerState();
}

class _TimePickerState extends State<TimePicker> {
  TimeOfDay? selectedTime;
  TimePickerEntryMode entryMode = TimePickerEntryMode.dial;
  Orientation? orientation;
  TextDirection textDirection = TextDirection.ltr;
  MaterialTapTargetSize tapTargetSize = MaterialTapTargetSize.padded;
  bool use24HourTime = false;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        children: <Widget>[
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: <Widget>[
                SizedBox(
                  width: MediaQuery.of(context).size.width * 0.5,
                  child: ElevatedButton(
                    child: Text(selectedTime != null
                        ? (selectedTime?.format(context) ?? "")
                        : "Time Picker"),
                    onPressed: () async {
                      final TimeOfDay? time = await showTimePicker(
                        context: context,
                        initialTime: selectedTime ?? TimeOfDay.now(),
                        initialEntryMode: entryMode,
                        orientation: orientation,
                        builder: (BuildContext context, Widget? child) {
                          return Theme(
                            data: Theme.of(context).copyWith(
                              materialTapTargetSize: tapTargetSize,
                            ),
                            child: Directionality(
                              textDirection: textDirection,
                              child: MediaQuery(
                                data: MediaQuery.of(context).copyWith(
                                  alwaysUse24HourFormat: use24HourTime,
                                ),
                                child: child!,
                              ),
                            ),
                          );
                        },
                      );
                      setState(() {
                        selectedTime = time;
                        widget.getTime(time);
                      });
                    },
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

// Pick date from calender
class DatePicker extends StatefulWidget {
  const DatePicker({super.key, this.restorationId, required this.saveDate});

  final String? restorationId;
  final Function(DateTime?) saveDate;

  @override
  State<DatePicker> createState() => _DatePickerState();
}

class _DatePickerState extends State<DatePicker> with RestorationMixin {
  DateTime nullDate = DateTime(
      DateTime.now().year - 1, DateTime.now().month, DateTime.now().day);

  @override
  String? get restorationId => widget.restorationId;

  final RestorableDateTime _selectedDate = RestorableDateTime(DateTime.now());
  late final RestorableRouteFuture<DateTime?> _restorableDatePickerRouteFuture =
      RestorableRouteFuture<DateTime?>(
    onComplete: _selectDate,
    onPresent: (NavigatorState navigator, Object? arguments) {
      return navigator.restorablePush(
        _datePickerRoute,
        arguments: _selectedDate.value.millisecondsSinceEpoch,
      );
    },
  );

  @pragma('vm:entry-point')
  static Route<DateTime> _datePickerRoute(
    BuildContext context,
    Object? arguments,
  ) {
    return DialogRoute<DateTime>(
      context: context,
      builder: (BuildContext context) {
        return DatePickerDialog(
          restorationId: 'date_picker_dialog',
          initialEntryMode: DatePickerEntryMode.calendarOnly,
          initialDate: DateTime.fromMillisecondsSinceEpoch(arguments! as int),
          firstDate: DateTime.now(),
          lastDate: DateTime.now().add(const Duration(days: 365 * 20)),
        );
      },
    );
  }

  @override
  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {
    registerForRestoration(_selectedDate, 'selected_date');
    registerForRestoration(
        _restorableDatePickerRouteFuture, 'date_picker_route_future');
  }

  void _selectDate(DateTime? newSelectedDate) {
    if (newSelectedDate != null) {
      setState(() {
        nullDate = newSelectedDate;
        _selectedDate.value = newSelectedDate;
      });
      widget.saveDate(newSelectedDate);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: SizedBox(
        width: MediaQuery.of(context).size.width * 0.5,
        child: OutlinedButton(
          onPressed: () {
            _restorableDatePickerRouteFuture.present();
          },
          child: Text(nullDate !=
                  DateTime(DateTime.now().year - 1, DateTime.now().month,
                      DateTime.now().day)
              ? '${_selectedDate.value.day}/${_selectedDate.value.month}/${_selectedDate.value.year}'
              : "Date Picker"),
        ),
      ),
    );
  }
}
